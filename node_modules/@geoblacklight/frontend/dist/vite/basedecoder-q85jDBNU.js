"use strict";function l(o,e){let t=o.length-e,r=0;do{for(let a=e;a>0;a--)o[r+e]+=o[r],r++;t-=e}while(t>0)}function d(o,e,t){let r=0,a=o.length;const i=a/t;for(;a>e;){for(let n=e;n>0;--n)o[r+e]+=o[r],++r;a-=e}const s=o.slice();for(let n=0;n<i;++n)for(let c=0;c<t;++c)o[t*n+c]=s[(t-c-1)*i+n]}function f(o,e,t,r,a,i){if(!e||e===1)return o;for(let c=0;c<a.length;++c){if(a[c]%8!==0)throw new Error("When decoding with predictor, only multiple of 8 bits are supported.");if(a[c]!==a[0])throw new Error("When decoding with predictor, all samples must have the same size.")}const s=a[0]/8,n=i===2?1:a.length;for(let c=0;c<r&&!(c*n*t*s>=o.byteLength);++c){let h;if(e===2){switch(a[0]){case 8:h=new Uint8Array(o,c*n*t*s,n*t*s);break;case 16:h=new Uint16Array(o,c*n*t*s,n*t*s/2);break;case 32:h=new Uint32Array(o,c*n*t*s,n*t*s/4);break;default:throw new Error(`Predictor 2 not allowed with ${a[0]} bits per sample.`)}l(h,n)}else e===3&&(h=new Uint8Array(o,c*n*t*s,n*t*s),d(h,n,s))}return o}class g{async decode(e,t){const r=await this.decodeBlock(t),a=e.Predictor||1;if(a!==1){const i=!e.StripOffsets,s=i?e.TileWidth:e.ImageWidth,n=i?e.TileLength:e.RowsPerStrip||e.ImageLength;return f(r,a,s,n,e.BitsPerSample,e.PlanarConfiguration)}return r}}exports.BaseDecoder=g;
//# sourceMappingURL=basedecoder-q85jDBNU.js.map
