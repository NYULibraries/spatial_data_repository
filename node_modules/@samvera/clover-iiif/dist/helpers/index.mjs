import _ from "openseadragon";
import "@iiif/vault-helpers";
const u = (e) => {
  var n, o, r, s, c;
  let i = {
    id: typeof e == "string" ? e : e.source
  };
  if (typeof e == "string") {
    if (e.includes("#xywh=")) {
      const t = e.split("#xywh=");
      if (t && t[1]) {
        const [l, v, d, p] = t[1].split(",").map((f) => Number(f));
        i = {
          id: t[0],
          rect: {
            x: l,
            y: v,
            w: d,
            h: p
          }
        };
      }
    } else if (e.includes("#t=")) {
      const t = e.split("#t=");
      t && t[1] && (i = {
        id: t[0],
        t: t[1]
      });
    }
  } else if (typeof e == "object") {
    if (((n = e.selector) == null ? void 0 : n.type) === "PointSelector")
      i = {
        id: e.source,
        point: {
          x: e.selector.x,
          y: e.selector.y
        }
      };
    else if (((o = e.selector) == null ? void 0 : o.type) === "SvgSelector")
      i = {
        id: e.source,
        svg: e.selector.value
      };
    else if (((r = e.selector) == null ? void 0 : r.type) === "FragmentSelector" && (s = e.selector) != null && s.value.includes("xywh=") && e.source.type == "Canvas" && e.source.id) {
      const t = (c = e.selector) == null ? void 0 : c.value.split("xywh=");
      if (t && t[1]) {
        const [l, v, d, p] = t[1].split(",").map((f) => Number(f));
        i = {
          id: e.source.id,
          rect: {
            x: l,
            y: v,
            w: d,
            h: p
          }
        };
      }
    }
  }
  return i;
};
let h = window.OpenSeadragon;
if (!h && (h = _, !h))
  throw new Error("OpenSeadragon is missing.");
const w = "http://www.w3.org/2000/svg";
h.Viewer && (h.Viewer.prototype.svgOverlay = function() {
  return this._svgOverlayInfo ? this._svgOverlayInfo : (this._svgOverlayInfo = new a(this), this._svgOverlayInfo);
});
const a = function(e) {
  const i = this;
  this._viewer = e, this._containerWidth = 0, this._containerHeight = 0, this._svg = document.createElementNS(w, "svg"), this._svg.style.position = "absolute", this._svg.style.left = 0, this._svg.style.top = 0, this._svg.style.width = "100%", this._svg.style.height = "100%", this._viewer.canvas.appendChild(this._svg), this._node = document.createElementNS(w, "g"), this._svg.appendChild(this._node), this._viewer.addHandler("animation", function() {
    i.resize();
  }), this._viewer.addHandler("open", function() {
    i.resize();
  }), this._viewer.addHandler("rotate", function() {
    i.resize();
  }), this._viewer.addHandler("flip", function() {
    i.resize();
  }), this._viewer.addHandler("resize", function() {
    i.resize();
  }), this.resize();
};
a.prototype = {
  // ----------
  node: function() {
    return this._node;
  },
  // ----------
  resize: function() {
    this._containerWidth !== this._viewer.container.clientWidth && (this._containerWidth = this._viewer.container.clientWidth, this._svg.setAttribute("width", this._containerWidth)), this._containerHeight !== this._viewer.container.clientHeight && (this._containerHeight = this._viewer.container.clientHeight, this._svg.setAttribute("height", this._containerHeight));
    const e = this._viewer.viewport.pixelFromPoint(new h.Point(0, 0), !0), i = this._viewer.viewport.getZoom(!0), n = this._viewer.viewport.getRotation(), o = this._viewer.viewport.getFlip(), r = this._viewer.viewport._containerInnerSize.x;
    let s = r * i;
    const c = s;
    o && (s = -s, e.x = -e.x + r), this._node.setAttribute(
      "transform",
      "translate(" + e.x + "," + e.y + ") scale(" + s + "," + c + ") rotate(" + n + ")"
    );
  },
  // ----------
  onClick: function(e, i) {
    new h.MouseTracker({
      element: e,
      clickHandler: i
    }).setTracking(!0);
  }
};
function y(e, i, n) {
  let o, r, s = 40, c = 40;
  i.rect && (o = i.rect.x, r = i.rect.y, s = i.rect.w, c = i.rect.h), i.point && (o = i.point.x, r = i.point.y), u.svg;
  const t = 1 / e.width;
  return new _.Rect(
    o * t - s * t / 2 * (n - 1),
    r * t - c * t / 2 * (n - 1),
    s * t * n,
    c * t * n
  );
}
const m = { parseAnnotationTarget: u, createOpenSeadragonRect: y };
export {
  y as createOpenSeadragonRect,
  m as default,
  u as parseAnnotationTarget
};
//# sourceMappingURL=index.mjs.map
